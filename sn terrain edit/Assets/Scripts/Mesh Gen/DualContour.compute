#pragma kernel DualContour
#include "DualTables.compute"

// MUST be equal to Globals.threadGroupSize
static const int numthreads = 8;

struct Triangle {
    float3 vertexA;
    float3 vertexB;
    float3 vertexC;
    int type;
    
    void Swap(bool clockwise) {
        if (clockwise) {
            float3 temp = vertexA;
            vertexA = vertexC;
            vertexC = temp;
        }
    }
};
struct Face {
    float3 vertexA;
    float3 vertexB;
    float3 vertexC;
    float3 vertexD;
    int type;
};

// Fill beforehand, source data
RWStructuredBuffer<int> density;
RWStructuredBuffer<int> pointTypes;

// Output
AppendStructuredBuffer<Face> faces;

int numPointsX;
int numPointsY;
int numPointsZ;
float3 meshOffset;

int linearIndex(uint x, uint y, uint z) {
    return z * numPointsX * numPointsY + y * numPointsX + x;
}

bool checkBoundsAll(int3 pos) {
    return pos.x >= 0 && pos.y >= 0 && pos.z >= 0 && pos.x < numPointsX && pos.y < numPointsY && pos.z < numPointsZ;
}
bool checkBoundsOctree(int3 pos) {
    return pos.x > 0 && pos.y > 0 && pos.z > 0 && pos.x < 33 && pos.y < 33 && pos.z < 33;
}

float3 FindBestPoint(int x, int y, int z) {

    float3 pos = float3(0, 0, 0);
    int count = 0;
    
    float4 cubeCorners[8] = {
        float4(x, y, z,             decodeDensity(density[linearIndex(x, y, z)])),
        float4(x + 1, y, z,         decodeDensity(density[linearIndex(x + 1, y, z)])),
        float4(x + 1, y + 1, z,     decodeDensity(density[linearIndex(x + 1, y + 1, z)])),
        float4(x, y + 1, z,         decodeDensity(density[linearIndex(x, y + 1, z)])),
        float4(x, y, z + 1,         decodeDensity(density[linearIndex(x, y, z + 1)])),
        float4(x + 1, y, z + 1,     decodeDensity(density[linearIndex(x + 1, y, z + 1)])),
        float4(x + 1, y + 1, z + 1, decodeDensity(density[linearIndex(x + 1, y + 1, z + 1)])),
        float4(x, y + 1, z + 1,     decodeDensity(density[linearIndex(x, y + 1, z + 1)]))
    };

    return interpolateHalf(cubeCorners[0], cubeCorners[6]) + meshOffset;

    // find sum of all MC edge points
    for (int k = 0; k < 12; k++) {
        bool solid1 = cubeCorners[cornerIndexAFromEdge[k]].w > 0;
        bool solid2 = cubeCorners[cornerIndexBFromEdge[k]].w > 0;

        if (solid1 != solid2) {
            pos += interpolateHalf(cubeCorners[cornerIndexAFromEdge[k]], cubeCorners[cornerIndexBFromEdge[k]]);
            count++;
        }
    }

    if (count > 0) pos /= count;

    return (pos + meshOffset);
}

Face MakeFace(int3 p1, int3 p2, int dir, int type) {
    Face face;
    face.type = type;

    // For each edge that exhibits a sign change,
    // generate a quad connecting the minimizing vertices of the four cubes containing the edge.

    float3 cube1Index, cube2Index, cube3Index, cube4Index; 

    int3 pMin = int3(min(p1.x, p2.x), min(p1.y, p2.y), min(p1.z, p2.z));
    
    switch(dir) {
        default:
        case 0:
            // p1->p2 = y+
            cube1Index = float3(pMin.x - 1, pMin.y, pMin.z - 1);
            cube2Index = float3(pMin.x - 1, pMin.y, pMin.z);
            cube3Index = float3(pMin.x, pMin.y, pMin.z);
            cube4Index = float3(pMin.x, pMin.y, pMin.z - 1);
            break;
        case 1:
            // p1->p2 = y-
            cube1Index = float3(pMin.x - 1, pMin.y, pMin.z - 1);
            cube2Index = float3(pMin.x, pMin.y, pMin.z - 1);
            cube3Index = float3(pMin.x, pMin.y, pMin.z);
            cube4Index = float3(pMin.x - 1, pMin.y, pMin.z);
            break;
        case 2:
            // p1->p2 = x+
            cube1Index = float3(pMin.x, pMin.y - 1, pMin.z - 1);
            cube2Index = float3(pMin.x, pMin.y, pMin.z - 1);
            cube3Index = float3(pMin.x, pMin.y, pMin.z);
            cube4Index = float3(pMin.x, pMin.y - 1, pMin.z);
            break;
        case 3:
            // p1->p2 = x-
            cube1Index = float3(pMin.x, pMin.y - 1, pMin.z - 1);
            cube2Index = float3(pMin.x, pMin.y - 1, pMin.z);
            cube3Index = float3(pMin.x, pMin.y, pMin.z);
            cube4Index = float3(pMin.x, pMin.y, pMin.z - 1);
            break;
        case 4:
            // p1->p2 = z+
            cube1Index = float3(pMin.x - 1, pMin.y - 1, pMin.z);
            cube2Index = float3(pMin.x, pMin.y - 1, pMin.z);
            cube3Index = float3(pMin.x, pMin.y, pMin.z);
            cube4Index = float3(pMin.x - 1, pMin.y, pMin.z);
            break;
        case 5:
            // p1->p2 = z-
            cube1Index = float3(pMin.x - 1, pMin.y - 1, pMin.z);
            cube2Index = float3(pMin.x - 1, pMin.y,     pMin.z);
            cube3Index = float3(pMin.x, pMin.y,         pMin.z);
            cube4Index = float3(pMin.x, pMin.y - 1,     pMin.z);
            break;
    }

    face.vertexA = cube1Index;
    face.vertexB = cube2Index;
    face.vertexC = cube3Index;
    face.vertexD = cube4Index;

    return face;
}

int FindBestType(uint x, uint y, uint z) {
    
    for (int k = 0; k < 2; k++) {
        for (int j = 0; j < 2; j++) {
            for (int i = 0; i < 2; i++) {
                if (pointTypes[linearIndex(x + i, y + j, z + k)] != 0) {
                    return pointTypes[linearIndex(x + i, y + j, z + k)];
                }
            }
        }
    }
    return 0;
}

[numthreads(numthreads, numthreads, numthreads)]
void DualContour(int3 id : SV_DispatchThreadID) {

    if (checkBoundsOctree(id)) {

        // action per each cell
        int faceType = pointTypes[linearIndex(id.x, id.y, id.z)];
        int faceSignedDist = density[linearIndex(id.x, id.y, id.z)];

        if (isBelowSurface(faceType, faceSignedDist)) {
            for (int dir = 0; dir < 6; dir++) {
                int3 dirV = directionToPos[dir];
                int3 id1 = int3(id.x + dirV.x, id.y + dirV.y, id.z + dirV.z);

                int density1, type1;

                if (checkBoundsAll(id1)) {
                    density1 = density[linearIndex(id1.x, id1.y, id1.z)];
                    type1 = pointTypes[linearIndex(id1.x, id1.y, id1.z)];

                    if (!isBelowSurface(type1, density1)) {
                        faces.Append(MakeFace(id, id1, dir, faceType));
                    }
                }
            }
        }
    }
}